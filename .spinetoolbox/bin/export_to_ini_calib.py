import sys
import spinedb_api as api
from spinedb_api import DatabaseMapping
from tomlkit import *

from pathlib import Path
import os
import re
import fileinput

url = sys.argv[1]
outfile = sys.argv[2]
calib = sys.argv[3]
#url = "sqlite:///C:/Git/CWatM-spinetoolbox-dev/.spinetoolbox/items/data_store/cwatmdb_new.sqlite"
#outfile = "calib_ini"
def use_regex_date(filein):

	with open (filein, 'r' ) as f:
		content = f.read()
		content_new = re.sub('(\d{4})\-(\d{2})\-(\d{2}|[a-yA-Y]{3})', r'\3/\2/\1', content, flags = re.M)
	with open (filein, 'w' ) as f:
		f.write(content_new) 

	return
def replacetext(file, search_text, replace_text): 
  
    # Opening the file using the Path function 
    file = Path(r"{}".format(file))
  
    # Reading and storing the content of the file in 
    # a data variable 
    data = file.read_text() 
  
    # Replacing the text using the replace function 
    data = data.replace(search_text, replace_text) 
  
    # Writing the replaced data 
    # in the text file 
    file.write_text(data) 
  
    # Return "Text replaced" string 
    return

def replace_path(strin, dic, maincat):
	# identify if this is a path string
	str_mod = strin
	# Modify the root folder if it exist
	if "$" in strin:
		if ":" in strin:
			# This means this is a relative path, then look for the source and the variable in the source
			source = strin[(strin.find("(") + 1):strin.find(":")]
			var = strin[(strin.find(":") + 1):strin.find(")")]
			strori = dic[source][var]
			str_mod = str_mod.replace("$(" + source + ":" + var + ")", "{}")
			str_mod = str_mod.format(strori)
		else:
			source = strin[(strin.find("(") + 1):strin.find(")")]
			strori = dic[maincat][source]
			str_mod = str_mod.replace("$(" + source + ")", "{}")
			str_mod = str_mod.format(strori)
			# This means that it refers to another location in the structure data, extract the data from there	
	else:
		try:
			if isinstance(int(strin[0:4]),int):
				# If the first 4 digit are float then this is a date stored in string format. Reshape it to the CWatM format
				if strin.count(" ") > 0:
					strinsplit = strin.split(" ")
					for date in strinsplit:
						datesplit = date.split("-")
						str_mod_temp = [date.replace("-", "/") for date in strinsplit]
						str_mod = ""
						for idate in str_mod_temp:
							datesplit = idate.split("/")
							str_mod = str_mod + " {}/{}".format(datesplit[2], datesplit[1], datesplit[0])
				else:
					datesplit = strin.split("-")
					str_mod = "{}/{}/{}".format(datesplit[2], datesplit[1], datesplit[0])
		except:
			pass

	return str_mod

def retrieve_db(url, outfile, calib):
	doc = document()
	doc.add(comment("This is a TOML document is automatically generated by SpineToolbox"))
	with DatabaseMapping(url) as db_map:
		# Do something with db_map
		entity_classes = db_map.get_entity_class_items()
		keys = [entities["name"] for entities in entity_classes]
		print("This is the list of keys to be exported: ", keys)
		my_dictionary = dict.fromkeys(keys)
		param_val = db_map.get_parameter_value_items()
		#print(keys)
		#print("param_val ")
		# print(param_val)
		tomldoc = dict.fromkeys(keys)
		for key in keys:
			tomldoc[key] = table()

		for values in param_val:
			#print(values["value"])
			if values["type"] == 'array':
				data_spdb = api.from_database(values["value"], values["type"])
				datatemp = data_spdb._values
				try:
					# Check if the array contains float or integer values
					parse_as_digit = False
					if isinstance(datatemp[0],int) or isinstance(datatemp[0],float):
						parse_as_digit = True
					# Check if the digit is stored as string e.g. dates are stored as string
					elif datatemp[0].find("-") > 0:
						if isinstance(int(datatemp[0][0:4]), int):
							# Then this is a dates
							parse_as_digit = True
						else:
							# Then it might be a string with dash inside
							parse_as_digit = False
					if parse_as_digit:
						data = ' '.join([str(elem) for elem in datatemp])
					else:
						data = ', '.join([str(elem) for elem in datatemp])
				except:
					data = ', '.join([str(elem) for elem in datatemp])
				
			elif values["type"] == 'date_time':
				data_spdb = api.from_database(values["value"], values["type"])
				data = data_spdb.value.strftime("%Y-%m-%d")
			else:
				data  = api.from_database(values["value"], values["type"])

			if calib.lower() in ['false', '0'] and values['entity_name']=="CALIBRATION" and values['parameter_definition_name'] in ['OUT_Dir', 'OUT_TSS_Daily', 'OUT_TSS_MonthAvg']:
				continue

			dic = {values['parameter_definition_name']: data}
			print("Adding entity_name: ", values['entity_name'])
			print("     parameter_definition_name: ", values['parameter_definition_name'])
			print("     data: ", data)
			if not my_dictionary[values['entity_name']]:
				my_dictionary[values['entity_name']] = dic
				tomldoc[values['entity_name']].add(values['parameter_definition_name'], data)
			else:
				my_dictionary[values['entity_name']].update(dic)
				tomldoc[values['entity_name']][values['parameter_definition_name']]=data
		
		
		# Create output folders for each scenario and avoid writing errors in files
		#print(my_dictionary)
		if not my_dictionary["FILE_PATHS"] == None:
			print("Creating the directory")
			outputfolder = my_dictionary["FILE_PATHS"]["PathOut"]
			current_directory = os.getcwd()
			final_directory = os.path.join(current_directory, Path(r"{}".format(outputfolder)))
			if not os.path.exists(final_directory):
				os.makedirs(final_directory)
            # Re-write the path to the dictionnary to be used in the ini file
			tomldoc["FILE_PATHS"]["PathOut"]=final_directory
			my_dictionary["FILE_PATHS"]["PathOut"] = final_directory
		else:
			del my_dictionary['FILE_PATHS']
			doc.pop("FILE_PATHS")
		
		# Store the tomldoc values in the toml document
		for key in tomldoc:
			doc.add(key, tomldoc[key])
		#print(my_dictionary)
		#my_dictionary.pop("OUTPUT", None)
		#doc.pop("OUTPUT")
		# Check for empty key
		emptykey = list() 
		for key in my_dictionary:
			if my_dictionary[key] == None and calib.lower() in ['true', '1'] and key=="OUTPUT":
				# If the OUTPUT key exist but is not assign
				print("adding output section")
				doc.pop(key)
				addemptyoutput = True
				# print(key)
				emptykey.append(key)
			elif my_dictionary[key] == None:
				addemptyoutput = False
				doc.pop(key)
			else: 
				addemptyoutput = False
		#print(my_dictionary)
		'''
		This is checking the valid strings, dates and output in order to
		remove symbols and create an invalid toml file. This is because CWatM
		uses an invalid format of toml as .ini file 
		'''
		#dicti = my_dictionary.copy()
		#print(my_dictionary)
		#for values in dicti:
			# Replace PathRoot, PathOut, PathMeteo in subsequent strings
		#	if not dicti[values] == None:
		#		for var in dicti[values]:
		#			if isinstance(dicti[values][var], str):
		#				newstr = replace_path(dicti[values][var], dicti, values)
		#				dicti[values][var] = newstr
		#	else:
		#		del my_dictionary[values]
		if addemptyoutput:
			# Convert the dictionnary into a tomlkit valid document
			for emkey in emptykey:
				output = table()
				output.add(comment("This is an empty output file"))
				doc.add(emkey, output)
		print("Writing the toml object into the ini file")
		with Path(outfile+".ini").open("w") as fout:
				#print(tomlkit.dumps(my_dictionary))
			fout.write(dumps(doc))
		
		# Modify the ini file to be in a corrupt version of the CWatM
		# Character to be deleted
		replacetext(outfile+".ini", '"', "")	
		replacetext(outfile+".ini", "\\\\", "\\")
		use_regex_date(outfile+".ini")


retrieve_db(url, outfile, calib) 